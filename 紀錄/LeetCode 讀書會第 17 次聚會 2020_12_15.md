# LeetCode è®€æ›¸æœƒç¬¬ 17æ¬¡èšæœƒ 2020/12/15

leetcode è®€æ›¸æœƒé€šçŸ¥
1. é …ç›®: ç¬¬ 17 æ¬¡èšæœƒ
2. ç›®çš„: ç·šä¸Šä¸€èµ·å¯«é¡Œç›®, ç”±æœ‰æƒ³æ³•çš„äººå¸¶é ˜, å…ˆè§£é¡Œ, å†çœ‹è©²é¡Œæœ‰è¶£çš„è§£æ³•
3. æ™‚é–“: 12/15 (äºŒ) 20:00 ~ 21:00
4. åœ°é»: google meet ç·šä¸Š (å‰ 10 åˆ†é˜é å‚™éˆæ¥)
5. è§£é¡Œé …ç›®:  [Linked list - Two Pointer Technique](https://leetcode.com/explore/learn/card/linked-list/214/two-pointer-technique/)

6. å…±ç­†: GitHub https://github.com/programmingbookclub/Leetcode-club

é€šçŸ¥ 9 äºº: @æ¸¸è«­, @turtle, @james, @Louis, @TzuHsuan

å‚™è¨»: ä¸Šæ¬¡èŠåˆ°äº† Two pointer å¦‚ä½•æª¢æŸ¥ list æ˜¯å¦æœ‰ cycle (Linked List cycle)ï¼Œæ¥ä¸‹ä¾†æ˜¯ Linked List Cycle II

è«‹åœ¨ issue å›å ±ä¸€ä¸‹ï¼Œæˆ‘æœƒæŠŠä½ åŠ å…¥ contribution


---

## 142. Linked List Cycle II

```swift
// swift

extension ListNode {
    var id:ObjectIdentifier {ObjectIdentifier(self)}
}
var easyMode = false
class Solution {
    var map:[ObjectIdentifier: ListNode] = [:]
    
    func detectCycle(_ head: ListNode?) -> ListNode? {
        return easyMode ? detectCycle1(head) : detectCycle2(head) 
    }
    
    
    
    
    
    
    
    // mark: - easy by hash map
    
    
    
    func detectCycle1(_ head: ListNode?) -> ListNode? {
        guard let _head = head else {return nil}
        map[_head.id] = _head
        var ptr = head
        while true {
            ptr = ptr?.next
            guard let _ptr = ptr else {return nil}
            if let node = map[_ptr.id] {
                return node
            }
            map[_ptr.id] = _ptr
        }
    }
    
    // mark: - Floyd's è§€å¯Ÿæ³•
    
    func detectCycle2(_ head: ListNode?) -> ListNode? {
        if head == nil {return head}
        let intersect = getIntersect(head)
        if intersect == nil {return nil}
        var ptr1 = head
        var ptr2 = intersect
        while true {
            if ptr1 === ptr2 {return ptr1}
            ptr1 = ptr1?.next
            ptr2 = ptr2?.next
        }
        
    }
    func getIntersect(_ head: ListNode?) -> ListNode?{
        var p1 = head
        var p2 = head
        while true {
            if p2 == nil, p2?.next == nil {return nil}
            p1 = p1?.next
            p2 = p2?.next?.next
            if p1 === p2 {return p2}

        }
    }
}
```

### Floyd's è§€å¯Ÿæ³•

![](https://i.imgur.com/MPzf7pb.jpg)


```swift
//swift

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public var val: Int
 *     public var next: ListNode?
 *     public init(_ val: Int) {
 *         self.val = val
 *         self.next = nil
 *     }
 * }
 */

class Solution {
    func detectCycle(_ head: ListNode?) -> ListNode? {
        var intercept = hasCycle(head) 
        if intersect == nil {return nil} 
        var h = head
        while true {
            if h === intersect {return h}
            h = h?.next
            intersect = intersect?.next
        }
    }
    // a - b - c - d - b
    /*
        p 1 a b c d 
        q 2 a c b d  
        -> d is intersect
        å°æ˜ 2m/s å°è¯ 3m/s -ã€‹ 200 m/loop åœ¨ä»€éº¼ m äº¤ç–Š
            s-----------f
            l = loop length
            k-----s--i-----s
            --K---| I|
                  |-----L---|
                     ----K--|
            s1 = 1t = k+i 
            s2 = 2t = k + nL + i
            2(k + i) = k+i + nL
            k+i = L 
            k+i = i + (L - i)
            k = L - i (intersect node)
        a - b - c - d - b
        p1 intersect é‡åˆé»
        p 1: d - b - c - d - b - c - d
        h 1: a - b - c - d - b - c - d
                ğŸ‘†s loop start point
    */
    
    func hasCycle(_ head: ListNode?) -> ListNode? {
        var p1 = head
        var p2 = head
        while true {
            p1 = p1?.next
            p2 = p2?.next?.next
            if p2 == nil {return nil}
            if p1 === p2 {return p1}
        }
    }
}
```


---

### 160: Intersection of Two Linked Lists 

```swift
// swift
class Solution {
enum S {case timeout_o_mn, hashmap, twoptr}
    var s: S = .twoptr
    func getIntersectionNode(_ headA: ListNode?, _ headB: ListNode?) -> ListNode? {
         switch s {
            case .timeout_o_mn:
                return easy_getIntersectionNode(headA, headB)
            case .hashmap:
                return hashtable_getIntersectionNode(headA, headB)
            case .twoptr:
                return twoptr_getIntersectionNode(headA, headB)
        }
            
        
    }
    
    func easy_getIntersectionNode(_ headA: ListNode?, _ headB: ListNode?) -> ListNode? {
        var p1 = headA
        while true {
            if p1 == nil {return nil}
            var p2 = headB
            while true {
                if p2 == nil {break}
                if p2 === p1 {return p2}
                p2 = p2?.next
            }
            p1 = p1?.next
        }
    }
    func hashtable_getIntersectionNode(_ headA: ListNode?, _ headB: ListNode?) -> ListNode? {
        var cache: [ObjectIdentifier: ListNode] = [:]
        var p1 = headA
        while true {
            guard let _p1 = p1 else {break}
            cache[_p1.id] = _p1
            p1 = p1?.next
        }
        var p2 = headB
        while true {
            guard let _p2 = p2 else {return nil}
            if cache[_p2.id] != nil {return p2}
            p2 = p2?.next
        }
    }
    func twoptr_getIntersectionNode(_ headA: ListNode?, _ headB: ListNode?) -> ListNode? {
        var (pa, pb) = ( headA, headB)
        while true {
            if pa === pb {return pa}
            pa = (pa != nil) ? pa?.next : headB;
            pb = (pb != nil) ? pb?.next : headA;
        }
    }
}

// mark: - help
public extension ListNode {
    var id: ObjectIdentifier {.init(self)}
}


```text
A = [4,1,8,2,3], B = [5,6,1,8,2,3]
A         B
4,1,8,2,3,5,6,1,8,2,3
B           A
5,6,1,8,2,3,4,1,8,2,3,5,6,1,8,2,3
               ğŸ‘† é‡åˆé» a.k.a. solution
```
