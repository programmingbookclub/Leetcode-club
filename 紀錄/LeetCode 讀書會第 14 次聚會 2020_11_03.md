# LeetCode è®€æ›¸æœƒç¬¬ 14 æ¬¡èšæœƒ 2020/11/03

leetcode è®€æ›¸æœƒé€šçŸ¥
1. é …ç›®: ç¬¬ 14 æ¬¡èšæœƒ
2. ç›®çš„: ç·šä¸Šä¸€èµ·å¯«é¡Œç›®, ç”±æœ‰æƒ³æ³•çš„äººå¸¶é ˜, å…ˆè§£é¡Œ, å†çœ‹è©²é¡Œæœ‰è¶£çš„è§£æ³•
3. æ™‚é–“: 11/03(äºŒ) 20:00 ~ 21:00
4. åœ°é»: google meet ç·šä¸Š (å‰ 10 åˆ†é˜é å‚™éˆæ¥)
5. è§£é¡Œé …ç›®:  [Recursion I - Recurrence Relation](https://leetcode.com/explore/learn/card/recursion-i/251/scenario-i-recurrence-relation/)

6. å…±ç­†: hackmd ä¸»é  (https://hackmd.io/Dj-vZ8WJTa-AWgKxNvserw?both)
é€šçŸ¥ 9 äºº: @Jonec å­æº, @æ¸¸è«­, @ttn, @Kira, @turtle, @EnPing, @james, @Louis, @TzuHsuan
å‚™è¨»: ä¸Šæ¬¡èšæœƒå®Œæˆäº† recursion I çš„ Principle of Recursion, é€™æ¬¡å°‡å¾ç¬¬äºŒå€‹éƒ¨åˆ†é–‹å§‹ Recurrence Relation

```swift
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public var val: Int
 *     public var next: ListNode?
 *     public init() { self.val = 0; self.next = nil; }
 *     public init(_ val: Int) { self.val = val; self.next = nil; }
 *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }
 * }
 */
class Solution {
    func reverseList(_ head: ListNode?) -> ListNode? {
        helper(head)
    }
    /*
     x -> a -> b -> c 
    
    x -> a -> (b -> c -> null) c -> a -> null
            b -> (c -> null) 
             c -> 
                null
    */
    //               c 
    func helper(_ head: ListNode?) -> ListNode? {
        if head == nil || head?.next == nil {return head}
        let newhead = helper(head?.next) // r2 ==> c -> b
        // newHead c -> null
        // head == b -> c -> null
        // head.next === newhead                       //  ğŸ‘‡ XX
        head?.next?.next = head            // a -> b === a -> b -> a -> b ....
        //newhead?.next = head               // c -> b ==> c -> a where newHead == c -> b, head == a
        head?.next = nil                   // a -> b ... ===> a -> null
        return newhead
    }    
}

    func reverseList(_ head: ListNode?) -> ListNode? {
        if head == nil || head?.next == nil {return head}  
        let newhead = helper(head?.next)
        head?.next?.next = head
        head?.next = nil       
        return newhead
    }    
```

```cpp
// C++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *pre = NULL;
        ListNode *cur = head;
        return reverse(pre, cur);
    }
    
    ListNode* reverse(ListNode *pre, ListNode *cur){
        if(cur == NULL){
            return pre;
        }
        ListNode* temp = cur->next;
        cur->next = pre;
        pre = cur;
        cur = temp;
        return reverse(pre, cur);
    }
};
```

![](https://i.imgur.com/krbicrM.jpg)

---
### è£œå……
#### ä½¿ç”¨ Loop ä¾†åš ReverseList
é›–ç„¶ ğŸ¦‘ èªªå¾ˆç°¡å–®ï¼Œä½†æ˜¯æˆ‘è©¦è‘—å»å¯«é‚„æ˜¯è¦ºå¾—æœ‰å›°é›£ï¼Œæ‰€ä»¥åœ¨é€™åˆ†äº«ä¸€ä¸‹å¦‚ä½•ç”¨ Loop ä¾†åš ReverseListï¼š

æˆ‘å€‘è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚ä½•å°‡ list æ‹†é–‹å†ä¸€å€‹ä¸€å€‹æ‹¼å›å»ã€‚

:::info
Ex: a -> b -> c -> nil

æˆ‘å€‘éœ€è¦åšä»¥ä¸‹å‹•ä½œï¼š
1. a -> nil , b -> c -> nil
2. b -> a -> nil , c -> nil
3. c -> b -> a -> nil , done

é€™å€‹è¡Œç‚ºå…¶å¯¦æ˜¯æˆ‘çœ‹äº†å…¶ä»–äººå¯«çš„æ‰çŸ¥é“ã€‚
ä»–çš„åšæ³•å…¶å¯¦ä¹Ÿå¾ˆç°¡å–®ï¼Œå°±æ˜¯ç”¨ä¸€å€‹è®Šæ•¸å°‡ node ä¸€å€‹ä¸€å€‹å­˜é€²å»ã€‚
:::

é‚£éº¼æˆ‘å€‘è¦å¦‚ä½•é€²è¡Œå‘¢ï¼Ÿ
æœ€ç°¡å–®çš„æƒ³æ³•å°±æ˜¯å°‡å·¦é‚Šçš„ç”±ä¸€å€‹è®Šæ•¸å­˜å–ã€‚

```kotlin=
func reverseList(_ head: ListNode?) -> ListNode? {
    var result: ListNode?
    
    return result
}
```

å†ä¾†ï¼Œå› ç‚ºå³é‚Šçš„ head æ˜¯ä¸€ç›´æ›´æ›çš„ï¼Œæ‰€ä»¥æˆ‘å€‘ä¹Ÿéœ€è¦è¨˜éŒ„ä¸‹ä¾†ï¼š
```kotlin=
func reverseList(_ head: ListNode?) -> ListNode? {
    var result: ListNode?
    var currentNode = head
    
    return result
}
```

é‚£éº¼æ¥ä¸‹ä¾†æˆ‘å€‘å°±è¦åšä¸€å€‹ loop ä¾†å¾ªç’°è®€å–æ–°çš„ headã€‚
è€Œé€™å€‹ loop æœƒåœ¨ currentNode == nil çš„æ™‚å€™åœæ­¢ï¼š
```kotlin=
func reverseList(_ head: ListNode?) -> ListNode? {
    var result: ListNode?
    var currentNode = head
    
    while(currentNode != nil) {
        // ...
    }
    
    return result
}
```

æœ€å¾Œå°±æ˜¯çœ‹çœ‹ Loop ä¸­çš„é‚è¼¯äº†ï¼š
```kotlin=
func reverseList(_ head: ListNode?) -> ListNode? {
    var result: ListNode?
    var currentNode = head
    
    while(currentNode != nil) {
        // å°‡ next å…ˆæŠ“ä½
        let next = currentNode?.next
        
        // å°‡ currentNode çš„ next æŒ‡å‘ å·²æ’å¥½çš„ ListNode
        currentNode?.next = result
        // å°‡æ–°æ’å¥½çš„ ListNode æ”¾å…¥ result
        result = currentNode
        
        // ç¹¼çºŒæª¢æŸ¥ä¸‹ä¸€å€‹ ListNode
        currentNode = next
    }
    
    return result
}
```

å¸Œæœ›é€™å°å¤§å®¶æœ‰å¹«åŠ©ã€‚