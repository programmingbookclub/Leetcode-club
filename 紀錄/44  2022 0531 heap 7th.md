# LeetCode è®€æ›¸æœƒç¬¬ 44 æ¬¡èšæœƒ 2022/05/31

## leetcode è®€æ›¸æœƒé€šçŸ¥

1. é …ç›®: ç¬¬ 44 æ¬¡èšæœƒ
2. ç›®çš„: ç·šä¸Šä¸€èµ·å¯«é¡Œç›®, ç”±æœ‰æƒ³æ³•çš„äººå¸¶é ˜, å…ˆè§£é¡Œ, å†çœ‹è©²é¡Œæœ‰è¶£çš„è§£æ³•
3. æ™‚é–“: 05/31 (äºŒ) 20:00 ~ 21:00
4. åœ°é»: google meet ç·šä¸Š (å‰ 10 åˆ†é˜é å‚™éˆæ¥)
5. è§£é¡Œé …ç›®:  [Heap](https://leetcode.com/explore/featured/card/heap/643/heap/)
6. å…±ç­†: GitHub https://github.com/programmingbookclub/Leetcode-club
7. å‚™è¨»: é€™æ¬¡åš MEDIUM	1642ï¼šFurthest Building You Can Reachï¼Œå¦‚æœæå‰è¬›å®Œï¼Œå¯ä»¥æå‰çœ‹ 295 ï¼ˆhardï¼‰
8. 


--- 

* 	[done] MEDIUM	215	Kth Largest Element in an Array	https://leetcode.com/problems/kth-largest-element-in-an-array
* 	[done] MEDIUM	347	Top K Frequent Elements	https://leetcode.com/problems/top-k-frequent-elements
* 	[done] EASY	703	Kth Largest Element in a Stream	https://leetcode.com/problems/kth-largest-element-in-a-stream
* 	[done] EASY	1046	Last Stone Weight	https://leetcode.com/problems/last-stone-weight
* 	[done] EASY	1337	The K Weakest Rows in a Matrix	https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix
* 	[done] MEDIUM	378	Kth Smallest Element in a Sorted Matrix	https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix
* 	ğŸ”“	MEDIUM	253	Meeting Rooms II	https://leetcode.com/problems/meeting-rooms-ii
* 	[done] MEDIUM	973	K Closest Points to Origin	https://leetcode.com/problems/k-closest-points-to-origin
* 	ğŸ”“	MEDIUM	1167	Minimum Cost to Connect Sticks	https://leetcode.com/problems/minimum-cost-to-connect-sticks
* 	MEDIUM	1642	Furthest Building You Can Reach	https://leetcode.com/problems/furthest-building-you-can-reach
* 	HARD	295	Find Median from Data Stream	https://leetcode.com/problems/find-median-from-data-stream
*   MEDIUM 1631 Path With Minimum Effort https://leetcode.com/problems/path-with-minimum-effort/

---


```python
from typing import List
import heapq
class Solution:
    def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -> int:
        # a. use ladder optimally
        # keep tracking the usage of bricks
        # and if the sum of usage is more than bricks we have, we'll need ladder anyway)
        # use the ladder at the 'biggest gap', and minus from the sum of usage
        
        # b. use bricks optimally
        # the other way around is to use bricks optimally:
        # keep add gaps into the heap, and we only pop out the 'smallest gap' for brick usage
        
        # time O(N*logN), where N is the length of heights
        # space O(N)
        
        prev = float('inf')             # æœ€å¤§çš„
        hp = []                         # heap of brick usage
        brick_needed = 0                # sum of gaps

        for i in range(len(heights)):

            # use ladder optimally
            if heights[i] > prev:
                brick_needed += heights[i]-prev
                heapq.heappush(hp, prev-heights[i])
                if brick_needed > bricks:
                    if ladders > 0:
                        brick_needed += heapq.heappop(hp)       # max heap (update brick_needed so we don't need so much)
                        # a.k.a. brick_needed -= -heapq.heappop(hp)
                        ladders -= 1
                    else:
                        return i-1

            # use bricks optimally
            # if heights[i] > prev:
            #     heapq.heappush(hp, heights[i]-prev)          
            # if len(hp) > ladders:
            #     brick_needed += heapq.heappop(hp)
            # if brick_needed > bricks:
            #     return i-1

            prev = heights[i]
            

        return len(heights)-1
```



```python
# 871
from typing import List
import collections
class Solution:
    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:
        # use DP
        if target > startFuel+sum([f for _, f in stations]): return -1
        if not stations: return 0 if startFuel >= target else -1

        # DP / dict (times of refuel)
        # key = refill times, value: remaining Fuel
        trips = {0:startFuel}
        pos, i = 0, 0
        minRefill = float('inf')

        while pos < target and i < len(stations):
            stationPosition, stationFuel = stations[i]
            tmp = collections.defaultdict()
            # print('trips:', trips, 'min refills:', minRefill, 'pos:', pos, 'dis', stationPosition-pos)

            for refills, remainingFuel in trips.items():
                # print('refill, fuel, pos', refills, remainingFuel, pos)
                if pos + remainingFuel >= target:
                    minRefill = min(minRefill, refills)
                elif refills > minRefill or pos + remainingFuel < stationPosition:
                    continue
                else:
                    dist = stationPosition-pos
                    if refills in tmp:
                        tmp[refills] = max(tmp[refills], remainingFuel-dist)
                    else:
                        tmp[refills] = remainingFuel-dist
                    if refills+1 in tmp:
                        tmp[refills+1] = max(tmp[refills+1], remainingFuel-dist+stationFuel)
                    else:
                        tmp[refills+1] = remainingFuel-dist+stationFuel

            pos, trips = stationPosition, tmp
            i += 1
            # print('trips now:', trips, 'at pos: ', pos)
        
        # print('trips:', trips, 'min refills:', minRefill, 'pos:', pos, 'i', i)
        if pos < target and i == len(stations):
            for refills, remainingFuel in trips.items():
                if pos + remainingFuel >= target:
                    minRefill = min(minRefill, refills)
            return -1 if minRefill == float('inf') else minRefill

        return min([k for k, _ in trips])
```

Y.J. Leeä¸‹åˆ8:15
å¤§æ¦‚å…©ç¨®è§£æ³•
optimally use the 1. ladder or 2. brick
æœƒç‰½æ¶‰åˆ° using max-heap or min-heap
Y.J. Leeä¸‹åˆ8:20
é‚£å€‹æ˜¯backtracking
Y.J. Leeä¸‹åˆ8:22
å—¯ æˆ‘è¬›çš„backtracking å–®ç´”æŒ‡ undo å‰ä¸€å‹• 
Y.J. Leeä¸‹åˆ8:24
ä½ å¾—åˆ°å®ƒäº†
Louis Suä¸‹åˆ8:28
o(ã€ƒâ€™â–½â€™ã€ƒ)o
Y.J. Leeä¸‹åˆ8:30
é˜¿å…­çš„è³ªå› æ•¸åˆ†è§£å§?
Y.J. Leeä¸‹åˆ8:32
æˆ‘è¦ºå¾—ä¸å¤ªåƒ
ä½†æ˜¯é€™å€‹å¤šè·¯ä¸¦æ­¸æˆ‘æ²’è½éQQ
Y.J. Leeä¸‹åˆ8:34
éƒ½æ²’äººå¯«å–” æˆ‘æŠŠæˆ‘çš„å¯«æ³•å…ˆä¸Ÿhackmdå¥½äº† å¤§å®¶å¯ä»¥è¨è«–
XD åŠ æ²¹ç«™é‚£é¡Œ æˆ‘å¥½åƒä¹Ÿæœ‰ æ‰¾æ‰¾
ä½ ä¸‹åˆ8:36
871
Y.J. Leeä¸‹åˆ8:37
Naive ä¸ç”¨çœ‹
Y.J. Leeä¸‹åˆ8:38
è¬æƒ¡ python maxheap æ˜¯è² çš„XD
åº•ä¸‹å°±æ˜¯ minheap
Y.J. Leeä¸‹åˆ8:40
871 æˆ‘æ˜¯ç”¨DPå–”
Y.J. Leeä¸‹åˆ8:42
#1642é€™å€‹åšæ³•æ‡‰è©²å°±éæ­· array, ä½†æ˜¯éç¨‹ä¸­ maintain ä¸€å€‹heap (either min or max)
Y.J. Leeä¸‹åˆ8:44
sudoku é€™å€‹æ»¿ç¶“å…¸çš„ backtracking
ç•«åˆ°æŸä¸€æ ¼ æ²’æ­¥äº† å‰é¢æŸä¸€æ­¥ä¸€å®šæœ‰éŒ¯ å…ˆå›æº¯ä¸Šä¸€æ­¥å†ç¹¼çºŒ
Y.J. Leeä¸‹åˆ8:47
#1642 çš„å•é¡Œåœ¨æ–¼ä»–æ²’æ­¥äº†ä¸ä¸€å®šä¸æ˜¯æœ€ä½³è§£ æ‰€ä»¥è®Šæˆè¦éæ­·æ•´å€‹æ¨¹ æœƒå¾ˆææ€–
æ²’çœ‹ +1 XD
Y.J. Leeä¸‹åˆ8:50
å…¶å¯¦dfså°±å¾ˆé¡ä¼¼å•¦  å¾ˆå¤šæƒ…å¢ƒä½ æœƒç›´æ¥æƒ³åˆ°dfsè€Œä¸æ˜¯backtracking
Y.J. Leeä¸‹åˆ8:52
dfs çš„ recursive call å¦‚æœæœ‰æŠŠå‰é¢åšçš„äº‹æƒ…undo å°±æœƒå…«æˆåƒ backtracking
Y.J. Leeä¸‹åˆ8:53
æ‰€ä»¥æˆ‘è½åˆ° backtracking æœƒç›´è¦ºæœ‰ undo æŸäº›æ±è¥¿
